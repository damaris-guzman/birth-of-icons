<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Black & White CHAOS</title>
  <style>
    :root {
      --bg: #ffffff;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      overflow: hidden;
      user-select: none;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    /* Subtle scanline/noise overlay for extra grit */
    .scanlines {
      position: fixed;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: multiply;
      background:
        repeating-linear-gradient(
          0deg,
          rgba(0,0,0,0.04) 0px,
          rgba(0,0,0,0.04) 2px,
          transparent 2px,
          transparent 4px
        );
      animation: jitter 1.2s steps(2) infinite;
    }

    @keyframes jitter {
      0% { transform: translateY(0); opacity: .9; }
      50% { transform: translateY(-0.5px); opacity: .95; }
      100% { transform: translateY(0); opacity: .9; }
    }

    /* Random flash to heighten chaotic feel */
    .flash {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: #ffffff;
      opacity: 0;
      animation: flash 7s infinite;
      mix-blend-mode: screen;
    }

    @keyframes flash {
      0%, 92% { opacity: 0; }
      93% { opacity: .15; }
      94% { opacity: 0; }
      96% { opacity: .08; }
      100% { opacity: 0; }
    }

    .hud {
      position: fixed;
      left: 12px; bottom: 12px;
      background: rgba(255,255,255,0.6);
      color: #000;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      letter-spacing: .02em;
      backdrop-filter: blur(4px);
      box-shadow: 0 4px 16px rgba(0,0,0,.12);
      user-select: text;
    }
    .dark .hud { background: rgba(0,0,0,0.55); color: #fff; }

    /* Yellow circle link */
    .yellow-circle {
      position: fixed;
      top: 50%;
      right: 30px;
      transform: translateY(-50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: yellow;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      text-decoration: none;
      color: black;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="scanlines"></div>
  <div class="flash"></div>
  <div class="hud" id="hud">SPACE: pause | I: invert | R: reshuffle</div>

  <!-- Yellow circle link -->
  <a href="page2.html" class="yellow-circle">Gasp!</a>

  <script>
    // ===== Canvas setup =====
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing ops
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // ===== Utilities =====
    const rand = (a, b) => Math.random() * (b - a) + a;
    const rint = (a, b) => Math.floor(rand(a, b + 1));
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const pick = arr => arr[(Math.random() * arr.length) | 0];

    const fract = x => x - Math.floor(x);
    function prng(seed) {
      return function() {
        seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5;
        return fract((seed >>> 0) / 4294967296);
      };
    }

    // ===== Shape class =====
    class JaggedShape {
      constructor(w, h, idx) {
        this.seed = (Math.random() * 0xffffffff) >>> 0;
        this.rand = prng(this.seed);

        this.cx = rand(-w*0.1, w*1.1);
        this.cy = rand(-h*0.1, h*1.1);
        this.baseR = rand(Math.min(w,h) * 0.03, Math.min(w,h) * 0.14);
        this.verts = rint(12, 26);
        this.rotation = rand(0, Math.PI * 2);
        this.rotSpeed = rand(-1, 1) * (Math.random() < 0.5 ? 0.004 : 0.008);

        const spd = rand(0.2, 1.2);
        const ang = rand(0, Math.PI * 2);
        this.vx = Math.cos(ang) * spd;
        this.vy = Math.sin(ang) * spd;

        this.jag = rand(0.35, 0.9);
        this.spike = rand(0.25, 0.75);
        this.freq = rand(0.002, 0.008);

        this.fill = this.rand() > 0.5 ? '#000' : '#fff';
        this.stroke = this.fill === '#000' ? '#fff' : '#000';
        this.alpha = rand(0.65, 0.94);
        this.lineWidth = rand(1.5, 3.5);

        this.points = [];
        for (let i = 0; i < this.verts; i++) {
          const t = i / this.verts;
          const angle = t * Math.PI * 2 + rand(-0.05, 0.05);
          const radius = this.baseR * (1 + rand(-this.jag, this.jag));
          this.points.push({ angle, radius, phase: rand(0, 1000) });
          const angle2 = angle + rand(0.02, 0.12);
          const radius2 = radius * (1 + this.spike + rand(-0.2, 0.2));
          this.points.push({ angle: angle2, radius: radius2, phase: rand(0, 1000) });
        }
      }

      step(bounds) {
        this.cx += this.vx;
        this.cy += this.vy;
        const m = Math.max(this.baseR * 2, 120);
        if (this.cx < -m) this.cx = bounds.w + m;
        if (this.cx > bounds.w + m) this.cx = -m;
        if (this.cy < -m) this.cy = bounds.h + m;
        if (this.cy > bounds.h + m) this.cy = -m;
        this.rotation += this.rotSpeed;
      }

      draw(t) {
        const { cx, cy, points, rotation, freq, stroke, fill, alpha, lineWidth } = this;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);
        ctx.globalAlpha = alpha;
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 1;

        ctx.beginPath();
        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          const jitter = Math.sin((t * freq) + p.phase) * (p.radius * 0.22);
          const r = Math.max(4, p.radius + jitter);
          const x = Math.cos(p.angle) * r;
          const y = Math.sin(p.angle) * r;
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();

        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = lineWidth * 1.25;
        ctx.stroke();
        ctx.fill();
        ctx.globalAlpha = clamp(alpha + 0.1, 0, 1);
        ctx.lineWidth = lineWidth * 0.6;
        ctx.stroke();

        ctx.restore();
      }
    }

    const state = { shapes: [], running: true, invert: false };

    function init() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      state.shapes = [];
      const count = Math.round((w * h) / 18000);
      for (let i = 0; i < count; i++) {
        state.shapes.push(new JaggedShape(w, h, i));
      }
    }

    function clear() {
      ctx.fillStyle = state.invert ? '#000' : '#fff';
      ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
    }

    function draw(tms) {
      if (!state.running) return;
      const t = tms * 0.001;
      clear();

      const order = state.shapes.slice();
      for (let i = order.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [order[i], order[j]] = [order[j], order[i]];
      }

      for (const s of order) {
        s.step({ w: window.innerWidth, h: window.innerHeight });
        if (state.invert) {
          s.fill = '#fff'; s.stroke = '#000';
        } else {
          s.fill = '#000'; s.stroke = '#fff';
        }
        s.draw(t);
      }

      requestAnimationFrame(draw);
    }

    init();
    requestAnimationFrame(draw);

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        state.running = !state.running;
        if (state.running) requestAnimationFrame(draw);
      } else if (e.key.toLowerCase() === 'i') {
        state.invert = !state.invert;
        document.body.classList.toggle('dark', state.invert);
      } else if (e.key.toLowerCase() === 'r') {
        init();
      }
    });

    window.addEventListener('pointerdown', () => {
      state.running = !state.running;
      if (state.running) requestAnimationFrame(draw);
    });
  </script>
</body>
</html>
